# netty-analysis

**Recycler** :netty自己写的对象缓冲池  
对象缓存池就是把不要的对象引用起来，在创建的时候直接获取(netty因为网络数据传输可能是碎片化的，创建和销毁对象很频繁)。  
缓存池有很多种策略，
netty是 自己线程回收自己对象的话，直接放置在关联的栈中。
每个栈还有一个对应的对象弱引用队列，其他线程回收的对象会放置在弱引用队列中，
如果当前线程复用对象时，栈中没有可用的对象，则从队列中获取。

**Nio** :  
1. 它本来是文件的多路复用技术，在c中，由于经常需要进程通信等等，Nio会频繁使用。
在netty中，它被用于网络通信(为何用于网络)。
    + 在linux下  
    使用过c的socket用户都知道，在创建套接字的时候，会有两个读写操作的fd传入。  
    用户发起创建一个tcp连接，该请求会被提交给内核，内核在内核区中申请一块内存区域，来
    存储该连接的元信息及窗口数据。内核收到数据后，会把该数据写回用户区内存。这时，旧版的阻塞
    io就能读取到数据，就能知道对方发送的消息了。  
2. 但是这样效率太地下，最终进化出了三种大类的解决方案。
    1. 最简单的方法，把fd设置为非阻塞，死循环，遍历获取所有fd的数据。
    2. 由内核告知哪些fd有数据需要被读取。用户告诉内核自己需要哪些fd的数据，内核去遍历后，返回
    给用户有数据的fd数组。因为用户去读取文件是要经过内核的，内存直接读取能够提交效率。
    3. 第二种方法在内核中的实现数据结构是数组，所有，它添加的fd数量是有上限的，而且内核也是通过线性遍历
    所有内核的内存来确定哪些fd有数据，效率低。第三种是把内核中的内存以红黑树链表的形式保存起来的，
    这样突破了数组的上限，也能让查询效率有一定提高。 
     
当然，所有这些都需要操作系统内核支持，如果不支持，Selector就会退化成最普通的文件遍历。